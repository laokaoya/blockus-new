{"ast":null,"code":"var _s = $RefreshSig$();\n// 游戏状态管理Hook\n\nimport { useState, useCallback, useEffect } from 'react';\nimport { PIECE_SHAPES, PIECE_COUNTS } from '../constants/pieces';\nimport { canPlacePiece, placePiece, calculateScore, isGameFinished } from '../utils/gameEngine';\nimport { AIPlayer } from '../utils/aiPlayer';\nconst BOARD_SIZE = 20;\nconst TURN_TIME_LIMIT = 30;\nexport function useGameState() {\n  _s();\n  // 初始化游戏状态\n  const [gameState, setGameState] = useState(() => initializeGameState());\n  const [aiPlayers, setAiPlayers] = useState([]);\n\n  // 初始化AI玩家\n  useEffect(() => {\n    const ais = [new AIPlayer('yellow'), new AIPlayer('blue'), new AIPlayer('green')];\n    setAiPlayers(ais);\n  }, []);\n\n  // 初始化游戏状态\n  function initializeGameState() {\n    const players = [createPlayer('red', '玩家'), createPlayer('yellow', 'AI-小黄'), createPlayer('blue', 'AI-小蓝'), createPlayer('green', 'AI-小绿')];\n\n    // 设置第一个玩家为当前回合\n    players[0].isCurrentTurn = true;\n    return {\n      board: Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(0)),\n      players,\n      currentPlayerIndex: 0,\n      gamePhase: 'playing',\n      turnTimeLimit: TURN_TIME_LIMIT,\n      timeLeft: TURN_TIME_LIMIT,\n      selectedPiece: null,\n      selectedPiecePosition: null\n    };\n  }\n\n  // 创建玩家\n  function createPlayer(color, name) {\n    const pieces = [];\n    let pieceId = 0;\n\n    // 为每种类型的拼图创建对应数量的实例\n    Object.entries(PIECE_COUNTS).forEach(([type, count]) => {\n      const pieceType = parseInt(type);\n      const shapes = PIECE_SHAPES[pieceType];\n      for (let i = 0; i < count; i++) {\n        const shapeIndex = i % shapes.length;\n        pieces.push({\n          id: `${color}-${pieceType}-${pieceId++}`,\n          type: pieceType,\n          shape: shapes[shapeIndex],\n          color,\n          isUsed: false\n        });\n      }\n    });\n    return {\n      id: color,\n      name,\n      color,\n      pieces,\n      score: 0,\n      isSettled: false,\n      isCurrentTurn: false\n    };\n  }\n\n  // 选择拼图\n  const selectPiece = useCallback(piece => {\n    setGameState(prev => ({\n      ...prev,\n      selectedPiece: piece\n    }));\n  }, []);\n\n  // 放置拼图\n  const placePieceOnBoard = useCallback(position => {\n    if (!gameState.selectedPiece) return false;\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n    const colorIndex = gameState.currentPlayerIndex + 1;\n    if (!canPlacePiece(gameState.board, gameState.selectedPiece, position, colorIndex)) {\n      return false;\n    }\n\n    // 放置拼图\n    const newBoard = placePiece(gameState.board, gameState.selectedPiece, position, colorIndex);\n\n    // 标记拼图为已使用\n    const newPlayers = gameState.players.map(player => {\n      if (player.id === currentPlayer.id) {\n        const newPieces = player.pieces.map(p => p.id === gameState.selectedPiece.id ? {\n          ...p,\n          isUsed: true\n        } : p);\n        return {\n          ...player,\n          pieces: newPieces\n        };\n      }\n      return player;\n    });\n\n    // 计算新得分\n    const newScore = calculateScore(newBoard, colorIndex);\n    const updatedPlayers = newPlayers.map(player => player.id === currentPlayer.id ? {\n      ...player,\n      score: newScore\n    } : player);\n\n    // 进入下一回合\n    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n    const nextPlayers = updatedPlayers.map((player, index) => ({\n      ...player,\n      isCurrentTurn: index === nextPlayerIndex\n    }));\n    setGameState(prev => ({\n      ...prev,\n      board: newBoard,\n      players: nextPlayers,\n      currentPlayerIndex: nextPlayerIndex,\n      selectedPiece: null,\n      selectedPiecePosition: null,\n      timeLeft: TURN_TIME_LIMIT\n    }));\n    return true;\n  }, [gameState]);\n\n  // AI回合\n  const processAITurn = useCallback(() => {\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n\n    // 跳过玩家回合\n    if (currentPlayer.color === 'red') return;\n\n    // 延迟执行AI移动，让玩家看到\n    setTimeout(() => {\n      const aiPlayer = aiPlayers.find(ai => ai.getColor() === currentPlayer.color);\n      if (!aiPlayer) return;\n      const move = aiPlayer.makeMove(gameState.board, currentPlayer.pieces);\n      if (move) {\n        // AI放置拼图\n        const colorIndex = gameState.currentPlayerIndex + 1;\n        const newBoard = placePiece(gameState.board, move.piece, move.position, colorIndex);\n\n        // 更新玩家状态\n        const newPlayers = gameState.players.map(player => {\n          if (player.id === currentPlayer.id) {\n            const newPieces = player.pieces.map(p => p.id === move.piece.id ? {\n              ...p,\n              isUsed: true\n            } : p);\n            const newScore = calculateScore(newBoard, colorIndex);\n            return {\n              ...player,\n              pieces: newPieces,\n              score: newScore\n            };\n          }\n          return player;\n        });\n\n        // 进入下一回合\n        const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n        const nextPlayers = newPlayers.map((player, index) => ({\n          ...player,\n          isCurrentTurn: index === nextPlayerIndex\n        }));\n        setGameState(prev => ({\n          ...prev,\n          board: newBoard,\n          players: nextPlayers,\n          currentPlayerIndex: nextPlayerIndex,\n          timeLeft: TURN_TIME_LIMIT\n        }));\n      } else {\n        // AI无法放置拼图，进入结算\n        const newPlayers = gameState.players.map(player => player.id === currentPlayer.id ? {\n          ...player,\n          isSettled: true\n        } : player);\n\n        // 进入下一回合\n        const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n        const nextPlayers = newPlayers.map((player, index) => ({\n          ...player,\n          isCurrentTurn: index === nextPlayerIndex\n        }));\n        setGameState(prev => ({\n          ...prev,\n          players: nextPlayers,\n          currentPlayerIndex: nextPlayerIndex,\n          timeLeft: TURN_TIME_LIMIT\n        }));\n      }\n    }, 1000);\n  }, [gameState, aiPlayers]);\n\n  // 结算玩家\n  const settlePlayer = useCallback(() => {\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n    if (currentPlayer.color !== 'red') return;\n    const newPlayers = gameState.players.map(player => player.id === currentPlayer.id ? {\n      ...player,\n      isSettled: true\n    } : player);\n\n    // 进入下一回合\n    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n    const nextPlayers = newPlayers.map((player, index) => ({\n      ...player,\n      isCurrentTurn: index === nextPlayerIndex\n    }));\n    setGameState(prev => ({\n      ...prev,\n      players: nextPlayers,\n      currentPlayerIndex: nextPlayerIndex,\n      timeLeft: TURN_TIME_LIMIT\n    }));\n  }, [gameState]);\n\n  // 重置游戏\n  const resetGame = useCallback(() => {\n    setGameState(initializeGameState());\n  }, []);\n\n  // 倒计时\n  useEffect(() => {\n    if (gameState.gamePhase !== 'playing') return;\n    const timer = setInterval(() => {\n      setGameState(prev => {\n        if (prev.timeLeft <= 1) {\n          // 时间到，自动跳过或结算\n          const currentPlayer = prev.players[prev.currentPlayerIndex];\n          if (currentPlayer.color === 'red') {\n            // 玩家超时，自动结算\n            return {\n              ...prev,\n              players: prev.players.map(player => player.id === currentPlayer.id ? {\n                ...player,\n                isSettled: true\n              } : player),\n              currentPlayerIndex: (prev.currentPlayerIndex + 1) % prev.players.length,\n              timeLeft: TURN_TIME_LIMIT\n            };\n          } else {\n            // AI超时，自动跳过\n            return {\n              ...prev,\n              currentPlayerIndex: (prev.currentPlayerIndex + 1) % prev.players.length,\n              timeLeft: TURN_TIME_LIMIT\n            };\n          }\n        }\n        return {\n          ...prev,\n          timeLeft: prev.timeLeft - 1\n        };\n      });\n    }, 1000);\n    return () => clearInterval(timer);\n  }, [gameState.gamePhase, gameState.currentPlayerIndex]);\n\n  // 检查游戏是否结束\n  useEffect(() => {\n    if (isGameFinished(gameState.players)) {\n      setGameState(prev => ({\n        ...prev,\n        gamePhase: 'finished'\n      }));\n    }\n  }, [gameState.players]);\n\n  // 自动处理AI回合\n  useEffect(() => {\n    if (gameState.gamePhase === 'playing' && gameState.players[gameState.currentPlayerIndex].color !== 'red') {\n      processAITurn();\n    }\n  }, [gameState.currentPlayerIndex, gameState.gamePhase, processAITurn]);\n  return {\n    gameState,\n    selectPiece,\n    placePieceOnBoard,\n    settlePlayer,\n    resetGame\n  };\n}\n_s(useGameState, \"QPKsrLWkmwHx2FReS9LHgwjEBpI=\");","map":{"version":3,"names":["useState","useCallback","useEffect","PIECE_SHAPES","PIECE_COUNTS","canPlacePiece","placePiece","calculateScore","isGameFinished","AIPlayer","BOARD_SIZE","TURN_TIME_LIMIT","useGameState","_s","gameState","setGameState","initializeGameState","aiPlayers","setAiPlayers","ais","players","createPlayer","isCurrentTurn","board","Array","fill","map","currentPlayerIndex","gamePhase","turnTimeLimit","timeLeft","selectedPiece","selectedPiecePosition","color","name","pieces","pieceId","Object","entries","forEach","type","count","pieceType","parseInt","shapes","i","shapeIndex","length","push","id","shape","isUsed","score","isSettled","selectPiece","piece","prev","placePieceOnBoard","position","currentPlayer","colorIndex","newBoard","newPlayers","player","newPieces","p","newScore","updatedPlayers","nextPlayerIndex","nextPlayers","index","processAITurn","setTimeout","aiPlayer","find","ai","getColor","move","makeMove","settlePlayer","resetGame","timer","setInterval","clearInterval"],"sources":["D:/blockus new/blockus-game/src/hooks/useGameState.ts"],"sourcesContent":["// 游戏状态管理Hook\r\n\r\nimport { useState, useCallback, useEffect } from 'react';\r\nimport { GameState, Player, Piece, Position, PlayerColor } from '../types/game';\r\nimport { PIECE_SHAPES, PIECE_COUNTS, PLAYER_COLORS, PLAYER_NAMES } from '../constants/pieces';\r\nimport { canPlacePiece, placePiece, calculateScore, isGameFinished, getWinner } from '../utils/gameEngine';\r\nimport { AIPlayer } from '../utils/aiPlayer';\r\n\r\nconst BOARD_SIZE = 20;\r\nconst TURN_TIME_LIMIT = 30;\r\n\r\nexport function useGameState() {\r\n  // 初始化游戏状态\r\n  const [gameState, setGameState] = useState<GameState>(() => initializeGameState());\r\n  const [aiPlayers, setAiPlayers] = useState<AIPlayer[]>([]);\r\n  \r\n  // 初始化AI玩家\r\n  useEffect(() => {\r\n    const ais = [\r\n      new AIPlayer('yellow'),\r\n      new AIPlayer('blue'),\r\n      new AIPlayer('green')\r\n    ];\r\n    setAiPlayers(ais);\r\n  }, []);\r\n  \r\n  // 初始化游戏状态\r\n  function initializeGameState(): GameState {\r\n    const players: Player[] = [\r\n      createPlayer('red', '玩家'),\r\n      createPlayer('yellow', 'AI-小黄'),\r\n      createPlayer('blue', 'AI-小蓝'),\r\n      createPlayer('green', 'AI-小绿')\r\n    ];\r\n    \r\n    // 设置第一个玩家为当前回合\r\n    players[0].isCurrentTurn = true;\r\n    \r\n    return {\r\n      board: Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(0)),\r\n      players,\r\n      currentPlayerIndex: 0,\r\n      gamePhase: 'playing',\r\n      turnTimeLimit: TURN_TIME_LIMIT,\r\n      timeLeft: TURN_TIME_LIMIT,\r\n      selectedPiece: null,\r\n      selectedPiecePosition: null\r\n    };\r\n  }\r\n  \r\n  // 创建玩家\r\n  function createPlayer(color: PlayerColor, name: string): Player {\r\n    const pieces: Piece[] = [];\r\n    let pieceId = 0;\r\n    \r\n    // 为每种类型的拼图创建对应数量的实例\r\n    Object.entries(PIECE_COUNTS).forEach(([type, count]) => {\r\n      const pieceType = parseInt(type) as 1 | 2 | 3 | 4 | 5;\r\n      const shapes = PIECE_SHAPES[pieceType];\r\n      \r\n      for (let i = 0; i < count; i++) {\r\n        const shapeIndex = i % shapes.length;\r\n        pieces.push({\r\n          id: `${color}-${pieceType}-${pieceId++}`,\r\n          type: pieceType,\r\n          shape: shapes[shapeIndex],\r\n          color,\r\n          isUsed: false\r\n        });\r\n      }\r\n    });\r\n    \r\n    return {\r\n      id: color,\r\n      name,\r\n      color,\r\n      pieces,\r\n      score: 0,\r\n      isSettled: false,\r\n      isCurrentTurn: false\r\n    };\r\n  }\r\n  \r\n  // 选择拼图\r\n  const selectPiece = useCallback((piece: Piece) => {\r\n    setGameState(prev => ({\r\n      ...prev,\r\n      selectedPiece: piece\r\n    }));\r\n  }, []);\r\n  \r\n  // 放置拼图\r\n  const placePieceOnBoard = useCallback((position: Position) => {\r\n    if (!gameState.selectedPiece) return false;\r\n    \r\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\r\n    const colorIndex = gameState.currentPlayerIndex + 1;\r\n    \r\n    if (!canPlacePiece(gameState.board, gameState.selectedPiece, position, colorIndex)) {\r\n      return false;\r\n    }\r\n    \r\n    // 放置拼图\r\n    const newBoard = placePiece(gameState.board, gameState.selectedPiece, position, colorIndex);\r\n    \r\n    // 标记拼图为已使用\r\n    const newPlayers = gameState.players.map(player => {\r\n      if (player.id === currentPlayer.id) {\r\n        const newPieces = player.pieces.map(p => \r\n          p.id === gameState.selectedPiece!.id ? { ...p, isUsed: true } : p\r\n        );\r\n        return { ...player, pieces: newPieces };\r\n      }\r\n      return player;\r\n    });\r\n    \r\n    // 计算新得分\r\n    const newScore = calculateScore(newBoard, colorIndex);\r\n    const updatedPlayers = newPlayers.map(player => \r\n      player.id === currentPlayer.id ? { ...player, score: newScore } : player\r\n    );\r\n    \r\n    // 进入下一回合\r\n    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\r\n    const nextPlayers = updatedPlayers.map((player, index) => ({\r\n      ...player,\r\n      isCurrentTurn: index === nextPlayerIndex\r\n    }));\r\n    \r\n    setGameState(prev => ({\r\n      ...prev,\r\n      board: newBoard,\r\n      players: nextPlayers,\r\n      currentPlayerIndex: nextPlayerIndex,\r\n      selectedPiece: null,\r\n      selectedPiecePosition: null,\r\n      timeLeft: TURN_TIME_LIMIT\r\n    }));\r\n    \r\n    return true;\r\n  }, [gameState]);\r\n  \r\n  // AI回合\r\n  const processAITurn = useCallback(() => {\r\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\r\n    \r\n    // 跳过玩家回合\r\n    if (currentPlayer.color === 'red') return;\r\n    \r\n    // 延迟执行AI移动，让玩家看到\r\n    setTimeout(() => {\r\n      const aiPlayer = aiPlayers.find(ai => ai.getColor() === currentPlayer.color);\r\n      if (!aiPlayer) return;\r\n      \r\n      const move = aiPlayer.makeMove(gameState.board, currentPlayer.pieces);\r\n      \r\n      if (move) {\r\n        // AI放置拼图\r\n        const colorIndex = gameState.currentPlayerIndex + 1;\r\n        const newBoard = placePiece(gameState.board, move.piece, move.position, colorIndex);\r\n        \r\n        // 更新玩家状态\r\n        const newPlayers = gameState.players.map(player => {\r\n          if (player.id === currentPlayer.id) {\r\n            const newPieces = player.pieces.map(p => \r\n              p.id === move.piece.id ? { ...p, isUsed: true } : p\r\n            );\r\n            const newScore = calculateScore(newBoard, colorIndex);\r\n            return { ...player, pieces: newPieces, score: newScore };\r\n          }\r\n          return player;\r\n        });\r\n        \r\n        // 进入下一回合\r\n        const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\r\n        const nextPlayers = newPlayers.map((player, index) => ({\r\n          ...player,\r\n          isCurrentTurn: index === nextPlayerIndex\r\n        }));\r\n        \r\n        setGameState(prev => ({\r\n          ...prev,\r\n          board: newBoard,\r\n          players: nextPlayers,\r\n          currentPlayerIndex: nextPlayerIndex,\r\n          timeLeft: TURN_TIME_LIMIT\r\n        }));\r\n      } else {\r\n        // AI无法放置拼图，进入结算\r\n        const newPlayers = gameState.players.map(player => \r\n          player.id === currentPlayer.id ? { ...player, isSettled: true } : player\r\n        );\r\n        \r\n        // 进入下一回合\r\n        const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\r\n        const nextPlayers = newPlayers.map((player, index) => ({\r\n          ...player,\r\n          isCurrentTurn: index === nextPlayerIndex\r\n        }));\r\n        \r\n        setGameState(prev => ({\r\n          ...prev,\r\n          players: nextPlayers,\r\n          currentPlayerIndex: nextPlayerIndex,\r\n          timeLeft: TURN_TIME_LIMIT\r\n        }));\r\n      }\r\n    }, 1000);\r\n  }, [gameState, aiPlayers]);\r\n  \r\n  // 结算玩家\r\n  const settlePlayer = useCallback(() => {\r\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\r\n    \r\n    if (currentPlayer.color !== 'red') return;\r\n    \r\n    const newPlayers = gameState.players.map(player => \r\n      player.id === currentPlayer.id ? { ...player, isSettled: true } : player\r\n    );\r\n    \r\n    // 进入下一回合\r\n    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\r\n    const nextPlayers = newPlayers.map((player, index) => ({\r\n      ...player,\r\n      isCurrentTurn: index === nextPlayerIndex\r\n    }));\r\n    \r\n    setGameState(prev => ({\r\n      ...prev,\r\n      players: nextPlayers,\r\n      currentPlayerIndex: nextPlayerIndex,\r\n      timeLeft: TURN_TIME_LIMIT\r\n    }));\r\n  }, [gameState]);\r\n  \r\n  // 重置游戏\r\n  const resetGame = useCallback(() => {\r\n    setGameState(initializeGameState());\r\n  }, []);\r\n  \r\n  // 倒计时\r\n  useEffect(() => {\r\n    if (gameState.gamePhase !== 'playing') return;\r\n    \r\n    const timer = setInterval(() => {\r\n      setGameState(prev => {\r\n        if (prev.timeLeft <= 1) {\r\n          // 时间到，自动跳过或结算\r\n          const currentPlayer = prev.players[prev.currentPlayerIndex];\r\n          if (currentPlayer.color === 'red') {\r\n            // 玩家超时，自动结算\r\n            return {\r\n              ...prev,\r\n              players: prev.players.map(player => \r\n                player.id === currentPlayer.id ? { ...player, isSettled: true } : player\r\n              ),\r\n              currentPlayerIndex: (prev.currentPlayerIndex + 1) % prev.players.length,\r\n              timeLeft: TURN_TIME_LIMIT\r\n            };\r\n          } else {\r\n            // AI超时，自动跳过\r\n            return {\r\n              ...prev,\r\n              currentPlayerIndex: (prev.currentPlayerIndex + 1) % prev.players.length,\r\n              timeLeft: TURN_TIME_LIMIT\r\n            };\r\n          }\r\n        }\r\n        \r\n        return {\r\n          ...prev,\r\n          timeLeft: prev.timeLeft - 1\r\n        };\r\n      });\r\n    }, 1000);\r\n    \r\n    return () => clearInterval(timer);\r\n  }, [gameState.gamePhase, gameState.currentPlayerIndex]);\r\n  \r\n  // 检查游戏是否结束\r\n  useEffect(() => {\r\n    if (isGameFinished(gameState.players)) {\r\n      setGameState(prev => ({\r\n        ...prev,\r\n        gamePhase: 'finished'\r\n      }));\r\n    }\r\n  }, [gameState.players]);\r\n  \r\n  // 自动处理AI回合\r\n  useEffect(() => {\r\n    if (gameState.gamePhase === 'playing' && \r\n        gameState.players[gameState.currentPlayerIndex].color !== 'red') {\r\n      processAITurn();\r\n    }\r\n  }, [gameState.currentPlayerIndex, gameState.gamePhase, processAITurn]);\r\n  \r\n  return {\r\n    gameState,\r\n    selectPiece,\r\n    placePieceOnBoard,\r\n    settlePlayer,\r\n    resetGame\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}