{"ast":null,"code":"// 游戏引擎核心逻辑\n\n// 检查拼图是否可以放置在指定位置\nexport function canPlacePiece(board, piece, position, playerColorIndex) {\n  const {\n    shape\n  } = piece;\n  const {\n    x,\n    y\n  } = position;\n\n  // 检查是否超出边界\n  if (x < 0 || y < 0 || x + shape[0].length > board.length || y + shape.length > board[0].length) {\n    return false;\n  }\n  let hasCornerConnection = false;\n  let hasEdgeConnection = false;\n\n  // 检查每个格子\n  for (let row = 0; row < shape.length; row++) {\n    for (let col = 0; col < shape[row].length; col++) {\n      if (shape[row][col] === 0) continue;\n      const boardX = x + col;\n      const boardY = y + row;\n\n      // 检查是否与已有拼图重叠\n      if (board[boardY][boardX] !== 0) {\n        return false;\n      }\n\n      // 检查四个方向的连接情况\n      const directions = [{\n        dx: -1,\n        dy: 0\n      },\n      // 左\n      {\n        dx: 1,\n        dy: 0\n      },\n      // 右\n      {\n        dx: 0,\n        dy: -1\n      },\n      // 上\n      {\n        dx: 0,\n        dy: 1\n      } // 下\n      ];\n      for (const dir of directions) {\n        const checkX = boardX + dir.dx;\n        const checkY = boardY + dir.dy;\n        if (checkX >= 0 && checkX < board.length && checkY >= 0 && checkY < board[0].length) {\n          const cell = board[checkY][checkX];\n          if (cell === playerColorIndex) {\n            // 与己方拼图边相连，不允许\n            return false;\n          } else if (cell !== 0) {\n            // 与对手拼图相连\n            hasEdgeConnection = true;\n          }\n        }\n      }\n\n      // 检查四个角落的连接情况\n      const corners = [{\n        dx: -1,\n        dy: -1\n      },\n      // 左上\n      {\n        dx: 1,\n        dy: -1\n      },\n      // 右上\n      {\n        dx: -1,\n        dy: 1\n      },\n      // 左下\n      {\n        dx: 1,\n        dy: 1\n      } // 右下\n      ];\n      for (const corner of corners) {\n        const checkX = boardX + corner.dx;\n        const checkY = boardY + corner.dy;\n        if (checkX >= 0 && checkX < board.length && checkY >= 0 && checkY < board[0].length) {\n          const cell = board[checkY][checkX];\n          if (cell === playerColorIndex) {\n            hasCornerConnection = true;\n          }\n        }\n      }\n    }\n  }\n\n  // 首次放置必须在角落\n  if (isFirstMove(board, playerColorIndex)) {\n    return isInCorner(position, board.length);\n  }\n\n  // 后续放置必须有角落连接\n  return hasCornerConnection;\n}\n\n// 检查是否是首次移动\nfunction isFirstMove(board, playerColorIndex) {\n  for (let y = 0; y < board.length; y++) {\n    for (let x = 0; x < board[y].length; x++) {\n      if (board[y][x] === playerColorIndex) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// 检查是否在指定玩家的起始角落\nfunction isInCorner(position, boardSize, playerColorIndex) {\n  const {\n    x,\n    y\n  } = position;\n\n  // 为每个玩家分配不同的起始角落\n  switch (playerColorIndex) {\n    case 1:\n      // 红色玩家 - 左上角\n      return x === 0 && y === 0;\n    case 2:\n      // 黄色玩家 - 右上角\n      return x === boardSize - 1 && y === 0;\n    case 3:\n      // 蓝色玩家 - 右下角\n      return x === boardSize - 1 && y === boardSize - 1;\n    case 4:\n      // 绿色玩家 - 左下角\n      return x === 0 && y === boardSize - 1;\n    default:\n      return false;\n  }\n}\n\n// 放置拼图到棋盘\nexport function placePiece(board, piece, position, playerColorIndex) {\n  const newBoard = board.map(row => [...row]);\n  const {\n    shape\n  } = piece;\n  const {\n    x,\n    y\n  } = position;\n  for (let row = 0; row < shape.length; row++) {\n    for (let col = 0; col < shape[row].length; col++) {\n      if (shape[row][col] === 1) {\n        newBoard[y + row][x + col] = playerColorIndex;\n      }\n    }\n  }\n  return newBoard;\n}\n\n// 计算玩家得分\nexport function calculateScore(board, playerColorIndex) {\n  let score = 0;\n  for (let y = 0; y < board.length; y++) {\n    for (let x = 0; x < board[y].length; x++) {\n      if (board[y][x] === playerColorIndex) {\n        score++;\n      }\n    }\n  }\n  return score;\n}\n\n// 检查游戏是否结束\nexport function isGameFinished(players) {\n  return players.every(player => player.isSettled);\n}\n\n// 获取获胜者\nexport function getWinner(players) {\n  if (!isGameFinished(players)) return null;\n  return players.reduce((winner, player) => {\n    return player.score > winner.score ? player : winner;\n  });\n}\n\n// 检查玩家是否可以继续放置拼图\nexport function canPlayerContinue(board, pieces, playerColorIndex) {\n  for (const piece of pieces) {\n    if (piece.isUsed) continue;\n\n    // 尝试在棋盘的每个位置放置拼图\n    for (let y = 0; y < board.length; y++) {\n      for (let x = 0; x < board[y].length; x++) {\n        if (canPlacePiece(board, piece, {\n          x,\n          y\n        }, playerColorIndex)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["canPlacePiece","board","piece","position","playerColorIndex","shape","x","y","length","hasCornerConnection","hasEdgeConnection","row","col","boardX","boardY","directions","dx","dy","dir","checkX","checkY","cell","corners","corner","isFirstMove","isInCorner","boardSize","placePiece","newBoard","map","calculateScore","score","isGameFinished","players","every","player","isSettled","getWinner","reduce","winner","canPlayerContinue","pieces","isUsed"],"sources":["D:/blockus new/blockus-game/src/utils/gameEngine.ts"],"sourcesContent":["// 游戏引擎核心逻辑\r\n\r\nimport { GameState, Piece, Position, PlayerColor } from '../types/game';\r\n\r\n// 检查拼图是否可以放置在指定位置\r\nexport function canPlacePiece(\r\n  board: number[][],\r\n  piece: Piece,\r\n  position: Position,\r\n  playerColorIndex: number\r\n): boolean {\r\n  const { shape } = piece;\r\n  const { x, y } = position;\r\n  \r\n  // 检查是否超出边界\r\n  if (x < 0 || y < 0 || x + shape[0].length > board.length || y + shape.length > board[0].length) {\r\n    return false;\r\n  }\r\n  \r\n  let hasCornerConnection = false;\r\n  let hasEdgeConnection = false;\r\n  \r\n  // 检查每个格子\r\n  for (let row = 0; row < shape.length; row++) {\r\n    for (let col = 0; col < shape[row].length; col++) {\r\n      if (shape[row][col] === 0) continue;\r\n      \r\n      const boardX = x + col;\r\n      const boardY = y + row;\r\n      \r\n      // 检查是否与已有拼图重叠\r\n      if (board[boardY][boardX] !== 0) {\r\n        return false;\r\n      }\r\n      \r\n      // 检查四个方向的连接情况\r\n      const directions = [\r\n        { dx: -1, dy: 0 }, // 左\r\n        { dx: 1, dy: 0 },  // 右\r\n        { dx: 0, dy: -1 }, // 上\r\n        { dx: 0, dy: 1 }   // 下\r\n      ];\r\n      \r\n      for (const dir of directions) {\r\n        const checkX = boardX + dir.dx;\r\n        const checkY = boardY + dir.dy;\r\n        \r\n        if (checkX >= 0 && checkX < board.length && checkY >= 0 && checkY < board[0].length) {\r\n          const cell = board[checkY][checkX];\r\n          \r\n          if (cell === playerColorIndex) {\r\n            // 与己方拼图边相连，不允许\r\n            return false;\r\n          } else if (cell !== 0) {\r\n            // 与对手拼图相连\r\n            hasEdgeConnection = true;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // 检查四个角落的连接情况\r\n      const corners = [\r\n        { dx: -1, dy: -1 }, // 左上\r\n        { dx: 1, dy: -1 },  // 右上\r\n        { dx: -1, dy: 1 },  // 左下\r\n        { dx: 1, dy: 1 }    // 右下\r\n      ];\r\n      \r\n      for (const corner of corners) {\r\n        const checkX = boardX + corner.dx;\r\n        const checkY = boardY + corner.dy;\r\n        \r\n        if (checkX >= 0 && checkX < board.length && checkY >= 0 && checkY < board[0].length) {\r\n          const cell = board[checkY][checkX];\r\n          \r\n          if (cell === playerColorIndex) {\r\n            hasCornerConnection = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  // 首次放置必须在角落\r\n  if (isFirstMove(board, playerColorIndex)) {\r\n    return isInCorner(position, board.length);\r\n  }\r\n  \r\n  // 后续放置必须有角落连接\r\n  return hasCornerConnection;\r\n}\r\n\r\n// 检查是否是首次移动\r\nfunction isFirstMove(board: number[][], playerColorIndex: number): boolean {\r\n  for (let y = 0; y < board.length; y++) {\r\n    for (let x = 0; x < board[y].length; x++) {\r\n      if (board[y][x] === playerColorIndex) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// 检查是否在指定玩家的起始角落\r\nfunction isInCorner(position: Position, boardSize: number, playerColorIndex: number): boolean {\r\n  const { x, y } = position;\r\n  \r\n  // 为每个玩家分配不同的起始角落\r\n  switch (playerColorIndex) {\r\n    case 1: // 红色玩家 - 左上角\r\n      return x === 0 && y === 0;\r\n    case 2: // 黄色玩家 - 右上角\r\n      return x === boardSize - 1 && y === 0;\r\n    case 3: // 蓝色玩家 - 右下角\r\n      return x === boardSize - 1 && y === boardSize - 1;\r\n    case 4: // 绿色玩家 - 左下角\r\n      return x === 0 && y === boardSize - 1;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\n// 放置拼图到棋盘\r\nexport function placePiece(\r\n  board: number[][],\r\n  piece: Piece,\r\n  position: Position,\r\n  playerColorIndex: number\r\n): number[][] {\r\n  const newBoard = board.map(row => [...row]);\r\n  const { shape } = piece;\r\n  const { x, y } = position;\r\n  \r\n  for (let row = 0; row < shape.length; row++) {\r\n    for (let col = 0; col < shape[row].length; col++) {\r\n      if (shape[row][col] === 1) {\r\n        newBoard[y + row][x + col] = playerColorIndex;\r\n      }\r\n    }\r\n  }\r\n  \r\n  return newBoard;\r\n}\r\n\r\n// 计算玩家得分\r\nexport function calculateScore(board: number[][], playerColorIndex: number): number {\r\n  let score = 0;\r\n  for (let y = 0; y < board.length; y++) {\r\n    for (let x = 0; x < board[y].length; x++) {\r\n      if (board[y][x] === playerColorIndex) {\r\n        score++;\r\n      }\r\n    }\r\n  }\r\n  return score;\r\n}\r\n\r\n// 检查游戏是否结束\r\nexport function isGameFinished(players: any[]): boolean {\r\n  return players.every(player => player.isSettled);\r\n}\r\n\r\n// 获取获胜者\r\nexport function getWinner(players: any[]): any {\r\n  if (!isGameFinished(players)) return null;\r\n  \r\n  return players.reduce((winner, player) => {\r\n    return player.score > winner.score ? player : winner;\r\n  });\r\n}\r\n\r\n// 检查玩家是否可以继续放置拼图\r\nexport function canPlayerContinue(board: number[][], pieces: Piece[], playerColorIndex: number): boolean {\r\n  for (const piece of pieces) {\r\n    if (piece.isUsed) continue;\r\n    \r\n    // 尝试在棋盘的每个位置放置拼图\r\n    for (let y = 0; y < board.length; y++) {\r\n      for (let x = 0; x < board[y].length; x++) {\r\n        if (canPlacePiece(board, piece, { x, y }, playerColorIndex)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}