{"ast":null,"code":"var _s = $RefreshSig$();\n// 游戏状态管理Hook\n\nimport { useState, useCallback, useEffect } from 'react';\nimport { PIECE_SHAPES, PIECE_COUNTS } from '../constants/pieces';\nimport { canPlacePiece, placePiece, calculateScore, isGameFinished } from '../utils/gameEngine';\nimport { AIPlayer } from '../utils/aiPlayer';\nconst BOARD_SIZE = 20;\nconst TURN_TIME_LIMIT = 30;\nexport function useGameState() {\n  _s();\n  // 初始化游戏状态\n  const [gameState, setGameState] = useState(() => initializeGameState());\n  const [aiPlayers, setAiPlayers] = useState([]);\n\n  // 初始化AI玩家\n  useEffect(() => {\n    const ais = [new AIPlayer('yellow'), new AIPlayer('blue'), new AIPlayer('green')];\n    setAiPlayers(ais);\n  }, []);\n\n  // 初始化游戏状态\n  function initializeGameState() {\n    const players = [createPlayer('red', '玩家'), createPlayer('yellow', 'AI-小黄'), createPlayer('blue', 'AI-小蓝'), createPlayer('green', 'AI-小绿')];\n\n    // 设置第一个玩家为当前回合\n    players[0].isCurrentTurn = true;\n    return {\n      board: Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(0)),\n      players,\n      currentPlayerIndex: 0,\n      gamePhase: 'playing',\n      turnTimeLimit: TURN_TIME_LIMIT,\n      timeLeft: TURN_TIME_LIMIT,\n      selectedPiece: null,\n      selectedPiecePosition: null\n    };\n  }\n\n  // 创建玩家\n  function createPlayer(color, name) {\n    const pieces = [];\n    let pieceId = 0;\n\n    // 为每种类型的拼图创建对应数量的实例\n    Object.entries(PIECE_COUNTS).forEach(([type, count]) => {\n      const pieceType = parseInt(type);\n      const shapes = PIECE_SHAPES[pieceType];\n\n      // 每种类型只创建一个实例，使用第一个形状\n      pieces.push({\n        id: `${color}-${pieceType}-${pieceId++}`,\n        type: pieceType,\n        shape: shapes[0],\n        // 只使用第一个形状\n        color,\n        isUsed: false\n      });\n    });\n    return {\n      id: color,\n      name,\n      color,\n      pieces,\n      score: 0,\n      isSettled: false,\n      isCurrentTurn: false\n    };\n  }\n\n  // 选择拼图\n  const selectPiece = useCallback(piece => {\n    setGameState(prev => ({\n      ...prev,\n      selectedPiece: piece\n    }));\n  }, []);\n\n  // 放置拼图\n  const placePieceOnBoard = useCallback(position => {\n    if (!gameState.selectedPiece) return false;\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n    const colorIndex = gameState.currentPlayerIndex + 1;\n    if (!canPlacePiece(gameState.board, gameState.selectedPiece, position, colorIndex)) {\n      return false;\n    }\n\n    // 放置拼图\n    const newBoard = placePiece(gameState.board, gameState.selectedPiece, position, colorIndex);\n\n    // 标记拼图为已使用\n    const newPlayers = gameState.players.map(player => {\n      if (player.id === currentPlayer.id) {\n        const newPieces = player.pieces.map(p => p.id === gameState.selectedPiece.id ? {\n          ...p,\n          isUsed: true\n        } : p);\n        return {\n          ...player,\n          pieces: newPieces\n        };\n      }\n      return player;\n    });\n\n    // 计算新得分\n    const newScore = calculateScore(newBoard, colorIndex);\n    const updatedPlayers = newPlayers.map(player => player.id === currentPlayer.id ? {\n      ...player,\n      score: newScore\n    } : player);\n\n    // 进入下一回合\n    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n    const nextPlayers = updatedPlayers.map((player, index) => ({\n      ...player,\n      isCurrentTurn: index === nextPlayerIndex\n    }));\n    setGameState(prev => ({\n      ...prev,\n      board: newBoard,\n      players: nextPlayers,\n      currentPlayerIndex: nextPlayerIndex,\n      selectedPiece: null,\n      selectedPiecePosition: null,\n      timeLeft: nextPlayers[nextPlayerIndex].color === 'red' ? TURN_TIME_LIMIT : prev.timeLeft\n    }));\n    return true;\n  }, [gameState]);\n\n  // AI回合\n  const processAITurn = useCallback(() => {\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n\n    // 跳过玩家回合\n    if (currentPlayer.color === 'red') return;\n\n    // 延迟执行AI移动，让玩家看到\n    setTimeout(() => {\n      const aiPlayer = aiPlayers.find(ai => ai.getColor() === currentPlayer.color);\n      if (!aiPlayer) return;\n      const move = aiPlayer.makeMove(gameState.board, currentPlayer.pieces);\n      if (move) {\n        // AI放置拼图\n        const colorIndex = gameState.currentPlayerIndex + 1;\n        const newBoard = placePiece(gameState.board, move.piece, move.position, colorIndex);\n\n        // 更新玩家状态\n        const newPlayers = gameState.players.map(player => {\n          if (player.id === currentPlayer.id) {\n            const newPieces = player.pieces.map(p => p.id === move.piece.id ? {\n              ...p,\n              isUsed: true\n            } : p);\n            const newScore = calculateScore(newBoard, colorIndex);\n            return {\n              ...player,\n              pieces: newPieces,\n              score: newScore\n            };\n          }\n          return player;\n        });\n\n        // 进入下一回合\n        const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n        const nextPlayers = newPlayers.map((player, index) => ({\n          ...player,\n          isCurrentTurn: index === nextPlayerIndex\n        }));\n        setGameState(prev => ({\n          ...prev,\n          board: newBoard,\n          players: nextPlayers,\n          currentPlayerIndex: nextPlayerIndex,\n          timeLeft: nextPlayers[nextPlayerIndex].color === 'red' ? TURN_TIME_LIMIT : prev.timeLeft\n        }));\n      } else {\n        // AI无法放置拼图，进入结算\n        const newPlayers = gameState.players.map(player => player.id === currentPlayer.id ? {\n          ...player,\n          isSettled: true\n        } : player);\n\n        // 进入下一回合\n        const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n        const nextPlayers = newPlayers.map((player, index) => ({\n          ...player,\n          isCurrentTurn: index === nextPlayerIndex\n        }));\n        setGameState(prev => ({\n          ...prev,\n          players: nextPlayers,\n          currentPlayerIndex: nextPlayerIndex,\n          timeLeft: nextPlayers[nextPlayerIndex].color === 'red' ? TURN_TIME_LIMIT : prev.timeLeft\n        }));\n      }\n    }, 1000);\n  }, [gameState, aiPlayers]);\n\n  // 结算玩家\n  const settlePlayer = useCallback(() => {\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n    if (currentPlayer.color !== 'red') return;\n    const newPlayers = gameState.players.map(player => player.id === currentPlayer.id ? {\n      ...player,\n      isSettled: true\n    } : player);\n\n    // 进入下一回合\n    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n    const nextPlayers = newPlayers.map((player, index) => ({\n      ...player,\n      isCurrentTurn: index === nextPlayerIndex\n    }));\n    setGameState(prev => ({\n      ...prev,\n      players: nextPlayers,\n      currentPlayerIndex: nextPlayerIndex,\n      timeLeft: nextPlayers[nextPlayerIndex].color === 'red' ? TURN_TIME_LIMIT : prev.timeLeft\n    }));\n  }, [gameState]);\n\n  // 重置游戏\n  const resetGame = useCallback(() => {\n    setGameState(initializeGameState());\n  }, []);\n\n  // 倒计时 - 只有人类玩家有时间限制\n  useEffect(() => {\n    if (gameState.gamePhase !== 'playing') return;\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n\n    // 只有人类玩家（红色）有时间限制\n    if (currentPlayer.color !== 'red') return;\n    const timer = setInterval(() => {\n      setGameState(prev => {\n        if (prev.timeLeft <= 1) {\n          // 人类玩家超时，自动结算\n          return {\n            ...prev,\n            players: prev.players.map(player => player.id === currentPlayer.id ? {\n              ...player,\n              isSettled: true\n            } : player),\n            currentPlayerIndex: (prev.currentPlayerIndex + 1) % prev.players.length,\n            timeLeft: TURN_TIME_LIMIT\n          };\n        }\n        return {\n          ...prev,\n          timeLeft: prev.timeLeft - 1\n        };\n      });\n    }, 1000);\n    return () => clearInterval(timer);\n  }, [gameState.gamePhase, gameState.currentPlayerIndex]);\n\n  // 检查游戏是否结束\n  useEffect(() => {\n    if (isGameFinished(gameState.players)) {\n      setGameState(prev => ({\n        ...prev,\n        gamePhase: 'finished'\n      }));\n    }\n  }, [gameState.players]);\n\n  // 自动处理AI回合\n  useEffect(() => {\n    if (gameState.gamePhase === 'playing' && gameState.players[gameState.currentPlayerIndex].color !== 'red') {\n      processAITurn();\n    }\n  }, [gameState.currentPlayerIndex, gameState.gamePhase, processAITurn]);\n  return {\n    gameState,\n    selectPiece,\n    placePieceOnBoard,\n    settlePlayer,\n    resetGame\n  };\n}\n_s(useGameState, \"QPKsrLWkmwHx2FReS9LHgwjEBpI=\");","map":{"version":3,"names":["useState","useCallback","useEffect","PIECE_SHAPES","PIECE_COUNTS","canPlacePiece","placePiece","calculateScore","isGameFinished","AIPlayer","BOARD_SIZE","TURN_TIME_LIMIT","useGameState","_s","gameState","setGameState","initializeGameState","aiPlayers","setAiPlayers","ais","players","createPlayer","isCurrentTurn","board","Array","fill","map","currentPlayerIndex","gamePhase","turnTimeLimit","timeLeft","selectedPiece","selectedPiecePosition","color","name","pieces","pieceId","Object","entries","forEach","type","count","pieceType","parseInt","shapes","push","id","shape","isUsed","score","isSettled","selectPiece","piece","prev","placePieceOnBoard","position","currentPlayer","colorIndex","newBoard","newPlayers","player","newPieces","p","newScore","updatedPlayers","nextPlayerIndex","length","nextPlayers","index","processAITurn","setTimeout","aiPlayer","find","ai","getColor","move","makeMove","settlePlayer","resetGame","timer","setInterval","clearInterval"],"sources":["D:/blockus new/blockus-game/src/hooks/useGameState.ts"],"sourcesContent":["// 游戏状态管理Hook\r\n\r\nimport { useState, useCallback, useEffect } from 'react';\r\nimport { GameState, Player, Piece, Position, PlayerColor } from '../types/game';\r\nimport { PIECE_SHAPES, PIECE_COUNTS, PLAYER_COLORS, PLAYER_NAMES } from '../constants/pieces';\r\nimport { canPlacePiece, placePiece, calculateScore, isGameFinished, getWinner } from '../utils/gameEngine';\r\nimport { AIPlayer } from '../utils/aiPlayer';\r\n\r\nconst BOARD_SIZE = 20;\r\nconst TURN_TIME_LIMIT = 30;\r\n\r\nexport function useGameState() {\r\n  // 初始化游戏状态\r\n  const [gameState, setGameState] = useState<GameState>(() => initializeGameState());\r\n  const [aiPlayers, setAiPlayers] = useState<AIPlayer[]>([]);\r\n  \r\n  // 初始化AI玩家\r\n  useEffect(() => {\r\n    const ais = [\r\n      new AIPlayer('yellow'),\r\n      new AIPlayer('blue'),\r\n      new AIPlayer('green')\r\n    ];\r\n    setAiPlayers(ais);\r\n  }, []);\r\n  \r\n  // 初始化游戏状态\r\n  function initializeGameState(): GameState {\r\n    const players: Player[] = [\r\n      createPlayer('red', '玩家'),\r\n      createPlayer('yellow', 'AI-小黄'),\r\n      createPlayer('blue', 'AI-小蓝'),\r\n      createPlayer('green', 'AI-小绿')\r\n    ];\r\n    \r\n    // 设置第一个玩家为当前回合\r\n    players[0].isCurrentTurn = true;\r\n    \r\n    return {\r\n      board: Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(0)),\r\n      players,\r\n      currentPlayerIndex: 0,\r\n      gamePhase: 'playing',\r\n      turnTimeLimit: TURN_TIME_LIMIT,\r\n      timeLeft: TURN_TIME_LIMIT,\r\n      selectedPiece: null,\r\n      selectedPiecePosition: null\r\n    };\r\n  }\r\n  \r\n  // 创建玩家\r\n  function createPlayer(color: PlayerColor, name: string): Player {\r\n    const pieces: Piece[] = [];\r\n    let pieceId = 0;\r\n    \r\n    // 为每种类型的拼图创建对应数量的实例\r\n    Object.entries(PIECE_COUNTS).forEach(([type, count]) => {\r\n      const pieceType = parseInt(type) as 1 | 2 | 3 | 4 | 5;\r\n      const shapes = PIECE_SHAPES[pieceType];\r\n      \r\n      // 每种类型只创建一个实例，使用第一个形状\r\n      pieces.push({\r\n        id: `${color}-${pieceType}-${pieceId++}`,\r\n        type: pieceType,\r\n        shape: shapes[0], // 只使用第一个形状\r\n        color,\r\n        isUsed: false\r\n      });\r\n    });\r\n    \r\n    return {\r\n      id: color,\r\n      name,\r\n      color,\r\n      pieces,\r\n      score: 0,\r\n      isSettled: false,\r\n      isCurrentTurn: false\r\n    };\r\n  }\r\n  \r\n  // 选择拼图\r\n  const selectPiece = useCallback((piece: Piece) => {\r\n    setGameState(prev => ({\r\n      ...prev,\r\n      selectedPiece: piece\r\n    }));\r\n  }, []);\r\n  \r\n  // 放置拼图\r\n  const placePieceOnBoard = useCallback((position: Position) => {\r\n    if (!gameState.selectedPiece) return false;\r\n    \r\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\r\n    const colorIndex = gameState.currentPlayerIndex + 1;\r\n    \r\n    if (!canPlacePiece(gameState.board, gameState.selectedPiece, position, colorIndex)) {\r\n      return false;\r\n    }\r\n    \r\n    // 放置拼图\r\n    const newBoard = placePiece(gameState.board, gameState.selectedPiece, position, colorIndex);\r\n    \r\n    // 标记拼图为已使用\r\n    const newPlayers = gameState.players.map(player => {\r\n      if (player.id === currentPlayer.id) {\r\n        const newPieces = player.pieces.map(p => \r\n          p.id === gameState.selectedPiece!.id ? { ...p, isUsed: true } : p\r\n        );\r\n        return { ...player, pieces: newPieces };\r\n      }\r\n      return player;\r\n    });\r\n    \r\n    // 计算新得分\r\n    const newScore = calculateScore(newBoard, colorIndex);\r\n    const updatedPlayers = newPlayers.map(player => \r\n      player.id === currentPlayer.id ? { ...player, score: newScore } : player\r\n    );\r\n    \r\n    // 进入下一回合\r\n    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\r\n    const nextPlayers = updatedPlayers.map((player, index) => ({\r\n      ...player,\r\n      isCurrentTurn: index === nextPlayerIndex\r\n    }));\r\n    \r\n         setGameState(prev => ({\r\n       ...prev,\r\n       board: newBoard,\r\n       players: nextPlayers,\r\n       currentPlayerIndex: nextPlayerIndex,\r\n       selectedPiece: null,\r\n       selectedPiecePosition: null,\r\n       timeLeft: nextPlayers[nextPlayerIndex].color === 'red' ? TURN_TIME_LIMIT : prev.timeLeft\r\n     }));\r\n    \r\n    return true;\r\n  }, [gameState]);\r\n  \r\n  // AI回合\r\n  const processAITurn = useCallback(() => {\r\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\r\n    \r\n    // 跳过玩家回合\r\n    if (currentPlayer.color === 'red') return;\r\n    \r\n    // 延迟执行AI移动，让玩家看到\r\n    setTimeout(() => {\r\n      const aiPlayer = aiPlayers.find(ai => ai.getColor() === currentPlayer.color);\r\n      if (!aiPlayer) return;\r\n      \r\n      const move = aiPlayer.makeMove(gameState.board, currentPlayer.pieces);\r\n      \r\n      if (move) {\r\n        // AI放置拼图\r\n        const colorIndex = gameState.currentPlayerIndex + 1;\r\n        const newBoard = placePiece(gameState.board, move.piece, move.position, colorIndex);\r\n        \r\n        // 更新玩家状态\r\n        const newPlayers = gameState.players.map(player => {\r\n          if (player.id === currentPlayer.id) {\r\n            const newPieces = player.pieces.map(p => \r\n              p.id === move.piece.id ? { ...p, isUsed: true } : p\r\n            );\r\n            const newScore = calculateScore(newBoard, colorIndex);\r\n            return { ...player, pieces: newPieces, score: newScore };\r\n          }\r\n          return player;\r\n        });\r\n        \r\n        // 进入下一回合\r\n        const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\r\n        const nextPlayers = newPlayers.map((player, index) => ({\r\n          ...player,\r\n          isCurrentTurn: index === nextPlayerIndex\r\n        }));\r\n        \r\n                 setGameState(prev => ({\r\n           ...prev,\r\n           board: newBoard,\r\n           players: nextPlayers,\r\n           currentPlayerIndex: nextPlayerIndex,\r\n           timeLeft: nextPlayers[nextPlayerIndex].color === 'red' ? TURN_TIME_LIMIT : prev.timeLeft\r\n         }));\r\n      } else {\r\n        // AI无法放置拼图，进入结算\r\n        const newPlayers = gameState.players.map(player => \r\n          player.id === currentPlayer.id ? { ...player, isSettled: true } : player\r\n        );\r\n        \r\n        // 进入下一回合\r\n        const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\r\n        const nextPlayers = newPlayers.map((player, index) => ({\r\n          ...player,\r\n          isCurrentTurn: index === nextPlayerIndex\r\n        }));\r\n        \r\n        setGameState(prev => ({\r\n          ...prev,\r\n          players: nextPlayers,\r\n          currentPlayerIndex: nextPlayerIndex,\r\n          timeLeft: nextPlayers[nextPlayerIndex].color === 'red' ? TURN_TIME_LIMIT : prev.timeLeft\r\n        }));\r\n      }\r\n    }, 1000);\r\n  }, [gameState, aiPlayers]);\r\n  \r\n  // 结算玩家\r\n  const settlePlayer = useCallback(() => {\r\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\r\n    \r\n    if (currentPlayer.color !== 'red') return;\r\n    \r\n    const newPlayers = gameState.players.map(player => \r\n      player.id === currentPlayer.id ? { ...player, isSettled: true } : player\r\n    );\r\n    \r\n    // 进入下一回合\r\n    const nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\r\n    const nextPlayers = newPlayers.map((player, index) => ({\r\n      ...player,\r\n      isCurrentTurn: index === nextPlayerIndex\r\n    }));\r\n    \r\n    setGameState(prev => ({\r\n      ...prev,\r\n      players: nextPlayers,\r\n      currentPlayerIndex: nextPlayerIndex,\r\n      timeLeft: nextPlayers[nextPlayerIndex].color === 'red' ? TURN_TIME_LIMIT : prev.timeLeft\r\n    }));\r\n  }, [gameState]);\r\n  \r\n  // 重置游戏\r\n  const resetGame = useCallback(() => {\r\n    setGameState(initializeGameState());\r\n  }, []);\r\n  \r\n  // 倒计时 - 只有人类玩家有时间限制\r\n  useEffect(() => {\r\n    if (gameState.gamePhase !== 'playing') return;\r\n    \r\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\r\n    \r\n    // 只有人类玩家（红色）有时间限制\r\n    if (currentPlayer.color !== 'red') return;\r\n    \r\n    const timer = setInterval(() => {\r\n      setGameState(prev => {\r\n        if (prev.timeLeft <= 1) {\r\n          // 人类玩家超时，自动结算\r\n          return {\r\n            ...prev,\r\n            players: prev.players.map(player => \r\n              player.id === currentPlayer.id ? { ...player, isSettled: true } : player\r\n            ),\r\n            currentPlayerIndex: (prev.currentPlayerIndex + 1) % prev.players.length,\r\n            timeLeft: TURN_TIME_LIMIT\r\n          };\r\n        }\r\n        \r\n        return {\r\n          ...prev,\r\n          timeLeft: prev.timeLeft - 1\r\n        };\r\n      });\r\n    }, 1000);\r\n    \r\n    return () => clearInterval(timer);\r\n  }, [gameState.gamePhase, gameState.currentPlayerIndex]);\r\n  \r\n  // 检查游戏是否结束\r\n  useEffect(() => {\r\n    if (isGameFinished(gameState.players)) {\r\n      setGameState(prev => ({\r\n        ...prev,\r\n        gamePhase: 'finished'\r\n      }));\r\n    }\r\n  }, [gameState.players]);\r\n  \r\n  // 自动处理AI回合\r\n  useEffect(() => {\r\n    if (gameState.gamePhase === 'playing' && \r\n        gameState.players[gameState.currentPlayerIndex].color !== 'red') {\r\n      processAITurn();\r\n    }\r\n  }, [gameState.currentPlayerIndex, gameState.gamePhase, processAITurn]);\r\n  \r\n  return {\r\n    gameState,\r\n    selectPiece,\r\n    placePieceOnBoard,\r\n    settlePlayer,\r\n    resetGame\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}