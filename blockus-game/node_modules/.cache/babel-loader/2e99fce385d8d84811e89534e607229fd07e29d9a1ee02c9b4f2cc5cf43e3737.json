{"ast":null,"code":"// AI玩家算法\n\nimport { canPlacePiece } from './gameEngine';\nexport class AIPlayer {\n  constructor(color) {\n    this.color = void 0;\n    this.colorIndex = void 0;\n    this.color = color;\n    this.colorIndex = this.getColorIndex(color);\n  }\n\n  // 公共方法：获取颜色\n  getColor() {\n    return this.color;\n  }\n\n  // 获取颜色对应的索引\n  getColorIndex(color) {\n    const colorMap = {\n      red: 1,\n      yellow: 2,\n      blue: 3,\n      green: 4\n    };\n    return colorMap[color];\n  }\n\n  // AI的主要决策函数\n  makeMove(board, pieces) {\n    const availablePieces = pieces.filter(p => !p.isUsed);\n    if (availablePieces.length === 0) return null;\n\n    // 按优先级排序拼图：5格 > 4格 > 3格 > 2格 > 1格\n    const sortedPieces = availablePieces.sort((a, b) => b.type - a.type);\n\n    // 尝试放置每个拼图\n    for (const piece of sortedPieces) {\n      const position = this.findBestPosition(board, piece);\n      if (position) {\n        return {\n          piece,\n          position\n        };\n      }\n    }\n    return null;\n  }\n\n  // 寻找最佳放置位置\n  findBestPosition(board, piece) {\n    const positions = [];\n\n    // 遍历棋盘寻找所有可能的位置\n    for (let y = 0; y < board.length; y++) {\n      for (let x = 0; x < board[y].length; x++) {\n        if (canPlacePiece(board, piece, {\n          x,\n          y\n        }, this.colorIndex)) {\n          positions.push({\n            x,\n            y\n          });\n        }\n      }\n    }\n    if (positions.length === 0) return null;\n\n    // 评分并选择最佳位置\n    const scoredPositions = positions.map(pos => ({\n      position: pos,\n      score: this.evaluatePosition(board, piece, pos)\n    }));\n\n    // 按分数排序，选择最高分的位置\n    scoredPositions.sort((a, b) => b.score - a.score);\n    return scoredPositions[0].position;\n  }\n\n  // 评估位置分数\n  evaluatePosition(board, piece, position) {\n    let score = 0;\n    const {\n      x,\n      y\n    } = position;\n    const {\n      shape\n    } = piece;\n\n    // 优先选择靠近边缘的位置（向外拓展）\n    score += this.getEdgeDistanceScore(x, y, board.length);\n\n    // 优先选择靠近角落的位置\n    score += this.getCornerDistanceScore(x, y, board.length);\n\n    // 避免被对手包围\n    score += this.getSurroundingScore(board, x, y, shape);\n\n    // 优先选择能连接更多己方拼图的位置\n    score += this.getConnectionScore(board, x, y, shape);\n    return score;\n  }\n\n  // 计算到边缘的距离分数\n  getEdgeDistanceScore(x, y, boardSize) {\n    const distanceToEdge = Math.min(x, y, boardSize - 1 - x, boardSize - 1 - y);\n    return (boardSize - distanceToEdge) * 10; // 越靠近边缘分数越高\n  }\n\n  // 计算到角落的距离分数\n  getCornerDistanceScore(x, y, boardSize) {\n    const distanceToCorner = Math.min(Math.sqrt(x * x + y * y), Math.sqrt((boardSize - 1 - x) * (boardSize - 1 - x) + y * y), Math.sqrt(x * x + (boardSize - 1 - y) * (boardSize - 1 - y)), Math.sqrt((boardSize - 1 - x) * (boardSize - 1 - x) + (boardSize - 1 - y) * (boardSize - 1 - y)));\n    return (boardSize - distanceToCorner) * 5; // 越靠近角落分数越高\n  }\n\n  // 计算周围环境分数\n  getSurroundingScore(board, x, y, shape) {\n    let score = 0;\n\n    // 检查拼图周围8个方向\n    for (let dy = -1; dy <= 1; dy++) {\n      for (let dx = -1; dx <= 1; dx++) {\n        if (dx === 0 && dy === 0) continue;\n        const checkX = x + dx;\n        const checkY = y + dy;\n        if (checkX >= 0 && checkX < board.length && checkY >= 0 && checkY < board[0].length) {\n          const cell = board[checkY][checkX];\n          if (cell === 0) {\n            score += 5; // 空位加分\n          } else if (cell === this.colorIndex) {\n            score += 2; // 己方拼图加分\n          } else {\n            score -= 3; // 对手拼图减分\n          }\n        }\n      }\n    }\n    return score;\n  }\n\n  // 计算连接性分数\n  getConnectionScore(board, x, y, shape) {\n    let score = 0;\n\n    // 检查拼图每个格子周围的连接情况\n    for (let row = 0; row < shape.length; row++) {\n      for (let col = 0; col < shape[row].length; col++) {\n        if (shape[row][col] === 0) continue;\n        const boardX = x + col;\n        const boardY = y + row;\n\n        // 检查四个角落\n        const corners = [{\n          dx: -1,\n          dy: -1\n        }, {\n          dx: 1,\n          dy: -1\n        }, {\n          dx: -1,\n          dy: 1\n        }, {\n          dx: 1,\n          dy: 1\n        }];\n        for (const corner of corners) {\n          const checkX = boardX + corner.dx;\n          const checkY = boardY + corner.dy;\n          if (checkX >= 0 && checkX < board.length && checkY >= 0 && checkY < board[0].length) {\n            if (board[checkY][checkX] === this.colorIndex) {\n              score += 8; // 角落连接加分\n            }\n          }\n        }\n      }\n    }\n    return score;\n  }\n\n  // 检查是否需要结算（无法放置任何拼图）\n  shouldSettle(board, pieces) {\n    const availablePieces = pieces.filter(p => !p.isUsed);\n    for (const piece of availablePieces) {\n      for (let y = 0; y < board.length; y++) {\n        for (let x = 0; x < board[y].length; x++) {\n          if (canPlacePiece(board, piece, {\n            x,\n            y\n          }, this.colorIndex)) {\n            return false; // 还能放置拼图\n          }\n        }\n      }\n    }\n    return true; // 无法放置任何拼图，需要结算\n  }\n}","map":{"version":3,"names":["canPlacePiece","AIPlayer","constructor","color","colorIndex","getColorIndex","getColor","colorMap","red","yellow","blue","green","makeMove","board","pieces","availablePieces","filter","p","isUsed","length","sortedPieces","sort","a","b","type","piece","position","findBestPosition","positions","y","x","push","scoredPositions","map","pos","score","evaluatePosition","shape","getEdgeDistanceScore","getCornerDistanceScore","getSurroundingScore","getConnectionScore","boardSize","distanceToEdge","Math","min","distanceToCorner","sqrt","dy","dx","checkX","checkY","cell","row","col","boardX","boardY","corners","corner","shouldSettle"],"sources":["D:/blockus new/blockus-game/src/utils/aiPlayer.ts"],"sourcesContent":["// AI玩家算法\r\n\r\nimport { Piece, Position, PlayerColor } from '../types/game';\r\nimport { canPlacePiece, placePiece } from './gameEngine';\r\n\r\nexport class AIPlayer {\r\n  private color: PlayerColor;\r\n  private colorIndex: number;\r\n  \r\n  constructor(color: PlayerColor) {\r\n    this.color = color;\r\n    this.colorIndex = this.getColorIndex(color);\r\n  }\r\n  \r\n  // 公共方法：获取颜色\r\n  public getColor(): PlayerColor {\r\n    return this.color;\r\n  }\r\n  \r\n  // 获取颜色对应的索引\r\n  private getColorIndex(color: PlayerColor): number {\r\n    const colorMap: { [key in PlayerColor]: number } = {\r\n      red: 1,\r\n      yellow: 2,\r\n      blue: 3,\r\n      green: 4\r\n    };\r\n    return colorMap[color];\r\n  }\r\n  \r\n  // AI的主要决策函数\r\n  public makeMove(board: number[][], pieces: Piece[]): { piece: Piece; position: Position } | null {\r\n    const availablePieces = pieces.filter(p => !p.isUsed);\r\n    if (availablePieces.length === 0) return null;\r\n    \r\n    // 按优先级排序拼图：5格 > 4格 > 3格 > 2格 > 1格\r\n    const sortedPieces = availablePieces.sort((a, b) => b.type - a.type);\r\n    \r\n    // 尝试放置每个拼图\r\n    for (const piece of sortedPieces) {\r\n      const position = this.findBestPosition(board, piece);\r\n      if (position) {\r\n        return { piece, position };\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n  \r\n  // 寻找最佳放置位置\r\n  private findBestPosition(board: number[][], piece: Piece): Position | null {\r\n    const positions: Position[] = [];\r\n    \r\n    // 遍历棋盘寻找所有可能的位置\r\n    for (let y = 0; y < board.length; y++) {\r\n      for (let x = 0; x < board[y].length; x++) {\r\n        if (canPlacePiece(board, piece, { x, y }, this.colorIndex)) {\r\n          positions.push({ x, y });\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (positions.length === 0) return null;\r\n    \r\n    // 评分并选择最佳位置\r\n    const scoredPositions = positions.map(pos => ({\r\n      position: pos,\r\n      score: this.evaluatePosition(board, piece, pos)\r\n    }));\r\n    \r\n    // 按分数排序，选择最高分的位置\r\n    scoredPositions.sort((a, b) => b.score - a.score);\r\n    return scoredPositions[0].position;\r\n  }\r\n  \r\n  // 评估位置分数\r\n  private evaluatePosition(board: number[][], piece: Piece, position: Position): number {\r\n    let score = 0;\r\n    const { x, y } = position;\r\n    const { shape } = piece;\r\n    \r\n    // 优先选择靠近边缘的位置（向外拓展）\r\n    score += this.getEdgeDistanceScore(x, y, board.length);\r\n    \r\n    // 优先选择靠近角落的位置\r\n    score += this.getCornerDistanceScore(x, y, board.length);\r\n    \r\n    // 避免被对手包围\r\n    score += this.getSurroundingScore(board, x, y, shape);\r\n    \r\n    // 优先选择能连接更多己方拼图的位置\r\n    score += this.getConnectionScore(board, x, y, shape);\r\n    \r\n    return score;\r\n  }\r\n  \r\n  // 计算到边缘的距离分数\r\n  private getEdgeDistanceScore(x: number, y: number, boardSize: number): number {\r\n    const distanceToEdge = Math.min(x, y, boardSize - 1 - x, boardSize - 1 - y);\r\n    return (boardSize - distanceToEdge) * 10; // 越靠近边缘分数越高\r\n  }\r\n  \r\n  // 计算到角落的距离分数\r\n  private getCornerDistanceScore(x: number, y: number, boardSize: number): number {\r\n    const distanceToCorner = Math.min(\r\n      Math.sqrt(x * x + y * y),\r\n      Math.sqrt((boardSize - 1 - x) * (boardSize - 1 - x) + y * y),\r\n      Math.sqrt(x * x + (boardSize - 1 - y) * (boardSize - 1 - y)),\r\n      Math.sqrt((boardSize - 1 - x) * (boardSize - 1 - x) + (boardSize - 1 - y) * (boardSize - 1 - y))\r\n    );\r\n    return (boardSize - distanceToCorner) * 5; // 越靠近角落分数越高\r\n  }\r\n  \r\n  // 计算周围环境分数\r\n  private getSurroundingScore(board: number[][], x: number, y: number, shape: number[][]): number {\r\n    let score = 0;\r\n    \r\n    // 检查拼图周围8个方向\r\n    for (let dy = -1; dy <= 1; dy++) {\r\n      for (let dx = -1; dx <= 1; dx++) {\r\n        if (dx === 0 && dy === 0) continue;\r\n        \r\n        const checkX = x + dx;\r\n        const checkY = y + dy;\r\n        \r\n        if (checkX >= 0 && checkX < board.length && checkY >= 0 && checkY < board[0].length) {\r\n          const cell = board[checkY][checkX];\r\n          \r\n          if (cell === 0) {\r\n            score += 5; // 空位加分\r\n          } else if (cell === this.colorIndex) {\r\n            score += 2; // 己方拼图加分\r\n          } else {\r\n            score -= 3; // 对手拼图减分\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return score;\r\n  }\r\n  \r\n  // 计算连接性分数\r\n  private getConnectionScore(board: number[][], x: number, y: number, shape: number[][]): number {\r\n    let score = 0;\r\n    \r\n    // 检查拼图每个格子周围的连接情况\r\n    for (let row = 0; row < shape.length; row++) {\r\n      for (let col = 0; col < shape[row].length; col++) {\r\n        if (shape[row][col] === 0) continue;\r\n        \r\n        const boardX = x + col;\r\n        const boardY = y + row;\r\n        \r\n        // 检查四个角落\r\n        const corners = [\r\n          { dx: -1, dy: -1 }, { dx: 1, dy: -1 },\r\n          { dx: -1, dy: 1 }, { dx: 1, dy: 1 }\r\n        ];\r\n        \r\n        for (const corner of corners) {\r\n          const checkX = boardX + corner.dx;\r\n          const checkY = boardY + corner.dy;\r\n          \r\n          if (checkX >= 0 && checkX < board.length && checkY >= 0 && checkY < board[0].length) {\r\n            if (board[checkY][checkX] === this.colorIndex) {\r\n              score += 8; // 角落连接加分\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return score;\r\n  }\r\n  \r\n  // 检查是否需要结算（无法放置任何拼图）\r\n  public shouldSettle(board: number[][], pieces: Piece[]): boolean {\r\n    const availablePieces = pieces.filter(p => !p.isUsed);\r\n    \r\n    for (const piece of availablePieces) {\r\n      for (let y = 0; y < board.length; y++) {\r\n        for (let x = 0; x < board[y].length; x++) {\r\n          if (canPlacePiece(board, piece, { x, y }, this.colorIndex)) {\r\n            return false; // 还能放置拼图\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return true; // 无法放置任何拼图，需要结算\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}