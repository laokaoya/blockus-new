{"ast":null,"code":"// 游戏引擎核心逻辑\n// 检查拼图是否可以放置在指定位置\nexport function canPlacePiece(board,piece,position,playerColorIndex){const{shape}=piece;const{x,y}=position;// 检查是否超出边界\nif(x<0||y<0||x+shape[0].length>board.length||y+shape.length>board[0].length){return false;}let hasCornerConnection=false;let hasEdgeConnection=false;// 检查每个格子\nfor(let row=0;row<shape.length;row++){for(let col=0;col<shape[row].length;col++){if(shape[row][col]===0)continue;const boardX=x+col;const boardY=y+row;// 检查是否与已有拼图重叠\nif(board[boardY][boardX]!==0){return false;}// 检查四个方向的连接情况\nconst directions=[{dx:-1,dy:0},// 左\n{dx:1,dy:0},// 右\n{dx:0,dy:-1},// 上\n{dx:0,dy:1}// 下\n];for(const dir of directions){const checkX=boardX+dir.dx;const checkY=boardY+dir.dy;if(checkX>=0&&checkX<board.length&&checkY>=0&&checkY<board[0].length){const cell=board[checkY][checkX];if(cell===playerColorIndex){// 与己方拼图边相连，不允许\nreturn false;}else if(cell!==0){// 与对手拼图相连\nhasEdgeConnection=true;}}}// 检查四个角落的连接情况\nconst corners=[{dx:-1,dy:-1},// 左上\n{dx:1,dy:-1},// 右上\n{dx:-1,dy:1},// 左下\n{dx:1,dy:1}// 右下\n];for(const corner of corners){const checkX=boardX+corner.dx;const checkY=boardY+corner.dy;if(checkX>=0&&checkX<board.length&&checkY>=0&&checkY<board[0].length){const cell=board[checkY][checkX];if(cell===playerColorIndex){hasCornerConnection=true;}}}}}// 首次放置必须在角落\nif(isFirstMove(board,playerColorIndex)){return isInCorner(position,board.length,playerColorIndex);}// 后续放置必须有角落连接\nreturn hasCornerConnection;}// 检查是否是首次移动\nfunction isFirstMove(board,playerColorIndex){for(let y=0;y<board.length;y++){for(let x=0;x<board[y].length;x++){if(board[y][x]===playerColorIndex){return false;}}}return true;}// 检查是否在指定玩家的起始角落\nfunction isInCorner(position,boardSize,playerColorIndex){const{x,y}=position;// 为每个玩家分配不同的起始角落\nswitch(playerColorIndex){case 1:// 红色玩家 - 左上角\nreturn x===0&&y===0;case 2:// 黄色玩家 - 右上角\nreturn x===boardSize-1&&y===0;case 3:// 蓝色玩家 - 右下角\nreturn x===boardSize-1&&y===boardSize-1;case 4:// 绿色玩家 - 左下角\nreturn x===0&&y===boardSize-1;default:return false;}}// 放置拼图到棋盘\nexport function placePiece(board,piece,position,playerColorIndex){const newBoard=board.map(row=>[...row]);const{shape}=piece;const{x,y}=position;for(let row=0;row<shape.length;row++){for(let col=0;col<shape[row].length;col++){if(shape[row][col]===1){newBoard[y+row][x+col]=playerColorIndex;}}}return newBoard;}// 计算玩家得分\nexport function calculateScore(board,playerColorIndex){let score=0;for(let y=0;y<board.length;y++){for(let x=0;x<board[y].length;x++){if(board[y][x]===playerColorIndex){score++;}}}return score;}// 检查游戏是否结束\nexport function isGameFinished(players){return players.every(player=>player.isSettled);}// 获取获胜者\nexport function getWinner(players){if(!isGameFinished(players))return null;return players.reduce((winner,player)=>{return player.score>winner.score?player:winner;});}// 检查玩家是否可以继续放置拼图\nexport function canPlayerContinue(board,pieces,playerColorIndex){for(const piece of pieces){if(piece.isUsed)continue;// 尝试在棋盘的每个位置放置拼图\nfor(let y=0;y<board.length;y++){for(let x=0;x<board[y].length;x++){if(canPlacePiece(board,piece,{x,y},playerColorIndex)){return true;}}}}return false;}","map":{"version":3,"names":["canPlacePiece","board","piece","position","playerColorIndex","shape","x","y","length","hasCornerConnection","hasEdgeConnection","row","col","boardX","boardY","directions","dx","dy","dir","checkX","checkY","cell","corners","corner","isFirstMove","isInCorner","boardSize","placePiece","newBoard","map","calculateScore","score","isGameFinished","players","every","player","isSettled","getWinner","reduce","winner","canPlayerContinue","pieces","isUsed"],"sources":["D:/blockus new/blockus-game/src/utils/gameEngine.ts"],"sourcesContent":["// 游戏引擎核心逻辑\r\n\r\nimport { GameState, Piece, Position, PlayerColor } from '../types/game';\r\n\r\n// 检查拼图是否可以放置在指定位置\r\nexport function canPlacePiece(\r\n  board: number[][],\r\n  piece: Piece,\r\n  position: Position,\r\n  playerColorIndex: number\r\n): boolean {\r\n  const { shape } = piece;\r\n  const { x, y } = position;\r\n  \r\n  // 检查是否超出边界\r\n  if (x < 0 || y < 0 || x + shape[0].length > board.length || y + shape.length > board[0].length) {\r\n    return false;\r\n  }\r\n  \r\n  let hasCornerConnection = false;\r\n  let hasEdgeConnection = false;\r\n  \r\n  // 检查每个格子\r\n  for (let row = 0; row < shape.length; row++) {\r\n    for (let col = 0; col < shape[row].length; col++) {\r\n      if (shape[row][col] === 0) continue;\r\n      \r\n      const boardX = x + col;\r\n      const boardY = y + row;\r\n      \r\n      // 检查是否与已有拼图重叠\r\n      if (board[boardY][boardX] !== 0) {\r\n        return false;\r\n      }\r\n      \r\n      // 检查四个方向的连接情况\r\n      const directions = [\r\n        { dx: -1, dy: 0 }, // 左\r\n        { dx: 1, dy: 0 },  // 右\r\n        { dx: 0, dy: -1 }, // 上\r\n        { dx: 0, dy: 1 }   // 下\r\n      ];\r\n      \r\n      for (const dir of directions) {\r\n        const checkX = boardX + dir.dx;\r\n        const checkY = boardY + dir.dy;\r\n        \r\n        if (checkX >= 0 && checkX < board.length && checkY >= 0 && checkY < board[0].length) {\r\n          const cell = board[checkY][checkX];\r\n          \r\n          if (cell === playerColorIndex) {\r\n            // 与己方拼图边相连，不允许\r\n            return false;\r\n          } else if (cell !== 0) {\r\n            // 与对手拼图相连\r\n            hasEdgeConnection = true;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // 检查四个角落的连接情况\r\n      const corners = [\r\n        { dx: -1, dy: -1 }, // 左上\r\n        { dx: 1, dy: -1 },  // 右上\r\n        { dx: -1, dy: 1 },  // 左下\r\n        { dx: 1, dy: 1 }    // 右下\r\n      ];\r\n      \r\n      for (const corner of corners) {\r\n        const checkX = boardX + corner.dx;\r\n        const checkY = boardY + corner.dy;\r\n        \r\n        if (checkX >= 0 && checkX < board.length && checkY >= 0 && checkY < board[0].length) {\r\n          const cell = board[checkY][checkX];\r\n          \r\n          if (cell === playerColorIndex) {\r\n            hasCornerConnection = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  // 首次放置必须在角落\r\n  if (isFirstMove(board, playerColorIndex)) {\r\n    return isInCorner(position, board.length, playerColorIndex);\r\n  }\r\n  \r\n  // 后续放置必须有角落连接\r\n  return hasCornerConnection;\r\n}\r\n\r\n// 检查是否是首次移动\r\nfunction isFirstMove(board: number[][], playerColorIndex: number): boolean {\r\n  for (let y = 0; y < board.length; y++) {\r\n    for (let x = 0; x < board[y].length; x++) {\r\n      if (board[y][x] === playerColorIndex) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// 检查是否在指定玩家的起始角落\r\nfunction isInCorner(position: Position, boardSize: number, playerColorIndex: number): boolean {\r\n  const { x, y } = position;\r\n  \r\n  // 为每个玩家分配不同的起始角落\r\n  switch (playerColorIndex) {\r\n    case 1: // 红色玩家 - 左上角\r\n      return x === 0 && y === 0;\r\n    case 2: // 黄色玩家 - 右上角\r\n      return x === boardSize - 1 && y === 0;\r\n    case 3: // 蓝色玩家 - 右下角\r\n      return x === boardSize - 1 && y === boardSize - 1;\r\n    case 4: // 绿色玩家 - 左下角\r\n      return x === 0 && y === boardSize - 1;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\n// 放置拼图到棋盘\r\nexport function placePiece(\r\n  board: number[][],\r\n  piece: Piece,\r\n  position: Position,\r\n  playerColorIndex: number\r\n): number[][] {\r\n  const newBoard = board.map(row => [...row]);\r\n  const { shape } = piece;\r\n  const { x, y } = position;\r\n  \r\n  for (let row = 0; row < shape.length; row++) {\r\n    for (let col = 0; col < shape[row].length; col++) {\r\n      if (shape[row][col] === 1) {\r\n        newBoard[y + row][x + col] = playerColorIndex;\r\n      }\r\n    }\r\n  }\r\n  \r\n  return newBoard;\r\n}\r\n\r\n// 计算玩家得分\r\nexport function calculateScore(board: number[][], playerColorIndex: number): number {\r\n  let score = 0;\r\n  for (let y = 0; y < board.length; y++) {\r\n    for (let x = 0; x < board[y].length; x++) {\r\n      if (board[y][x] === playerColorIndex) {\r\n        score++;\r\n      }\r\n    }\r\n  }\r\n  return score;\r\n}\r\n\r\n// 检查游戏是否结束\r\nexport function isGameFinished(players: any[]): boolean {\r\n  return players.every(player => player.isSettled);\r\n}\r\n\r\n// 获取获胜者\r\nexport function getWinner(players: any[]): any {\r\n  if (!isGameFinished(players)) return null;\r\n  \r\n  return players.reduce((winner, player) => {\r\n    return player.score > winner.score ? player : winner;\r\n  });\r\n}\r\n\r\n// 检查玩家是否可以继续放置拼图\r\nexport function canPlayerContinue(board: number[][], pieces: Piece[], playerColorIndex: number): boolean {\r\n  for (const piece of pieces) {\r\n    if (piece.isUsed) continue;\r\n    \r\n    // 尝试在棋盘的每个位置放置拼图\r\n    for (let y = 0; y < board.length; y++) {\r\n      for (let x = 0; x < board[y].length; x++) {\r\n        if (canPlacePiece(board, piece, { x, y }, playerColorIndex)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}