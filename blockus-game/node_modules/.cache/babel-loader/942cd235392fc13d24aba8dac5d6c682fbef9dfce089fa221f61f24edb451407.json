{"ast":null,"code":"// AI玩家算法\nimport{canPlacePiece}from'./gameEngine';export class AIPlayer{constructor(color){this.color=void 0;this.colorIndex=void 0;this.color=color;this.colorIndex=this.getColorIndex(color);}// 公共方法：获取颜色\ngetColor(){return this.color;}// 获取颜色对应的索引\ngetColorIndex(color){const colorMap={red:1,yellow:2,blue:3,green:4};return colorMap[color];}// AI的主要决策函数\nmakeMove(board,pieces){const availablePieces=pieces.filter(p=>!p.isUsed);if(availablePieces.length===0)return null;// 按优先级排序拼图：5格 > 4格 > 3格 > 2格 > 1格\nconst sortedPieces=availablePieces.sort((a,b)=>b.type-a.type);// 尝试放置每个拼图\nfor(const piece of sortedPieces){const position=this.findBestPosition(board,piece);if(position){return{piece,position};}}return null;}// 寻找最佳放置位置\nfindBestPosition(board,piece){const positions=[];// 遍历棋盘寻找所有可能的位置\nfor(let y=0;y<board.length;y++){for(let x=0;x<board[y].length;x++){if(canPlacePiece(board,piece,{x,y},this.colorIndex)){positions.push({x,y});}}}if(positions.length===0)return null;// 评分并选择最佳位置\nconst scoredPositions=positions.map(pos=>({position:pos,score:this.evaluatePosition(board,piece,pos)}));// 按分数排序，选择最高分的位置\nscoredPositions.sort((a,b)=>b.score-a.score);return scoredPositions[0].position;}// 评估位置分数\nevaluatePosition(board,piece,position){let score=0;const{x,y}=position;const{shape}=piece;// 优先选择靠近边缘的位置（向外拓展）\nscore+=this.getEdgeDistanceScore(x,y,board.length);// 优先选择靠近角落的位置\nscore+=this.getCornerDistanceScore(x,y,board.length);// 避免被对手包围\nscore+=this.getSurroundingScore(board,x,y,shape);// 优先选择能连接更多己方拼图的位置\nscore+=this.getConnectionScore(board,x,y,shape);return score;}// 计算到边缘的距离分数\ngetEdgeDistanceScore(x,y,boardSize){const distanceToEdge=Math.min(x,y,boardSize-1-x,boardSize-1-y);return(boardSize-distanceToEdge)*10;// 越靠近边缘分数越高\n}// 计算到角落的距离分数\ngetCornerDistanceScore(x,y,boardSize){const distanceToCorner=Math.min(Math.sqrt(x*x+y*y),Math.sqrt((boardSize-1-x)*(boardSize-1-x)+y*y),Math.sqrt(x*x+(boardSize-1-y)*(boardSize-1-y)),Math.sqrt((boardSize-1-x)*(boardSize-1-x)+(boardSize-1-y)*(boardSize-1-y)));return(boardSize-distanceToCorner)*5;// 越靠近角落分数越高\n}// 计算周围环境分数\ngetSurroundingScore(board,x,y,shape){let score=0;// 检查拼图周围8个方向\nfor(let dy=-1;dy<=1;dy++){for(let dx=-1;dx<=1;dx++){if(dx===0&&dy===0)continue;const checkX=x+dx;const checkY=y+dy;if(checkX>=0&&checkX<board.length&&checkY>=0&&checkY<board[0].length){const cell=board[checkY][checkX];if(cell===0){score+=5;// 空位加分\n}else if(cell===this.colorIndex){score+=2;// 己方拼图加分\n}else{score-=3;// 对手拼图减分\n}}}}return score;}// 计算连接性分数\ngetConnectionScore(board,x,y,shape){let score=0;// 检查拼图每个格子周围的连接情况\nfor(let row=0;row<shape.length;row++){for(let col=0;col<shape[row].length;col++){if(shape[row][col]===0)continue;const boardX=x+col;const boardY=y+row;// 检查四个角落\nconst corners=[{dx:-1,dy:-1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:1,dy:1}];for(const corner of corners){const checkX=boardX+corner.dx;const checkY=boardY+corner.dy;if(checkX>=0&&checkX<board.length&&checkY>=0&&checkY<board[0].length){if(board[checkY][checkX]===this.colorIndex){score+=8;// 角落连接加分\n}}}}}return score;}// 检查是否需要结算（无法放置任何拼图）\nshouldSettle(board,pieces){const availablePieces=pieces.filter(p=>!p.isUsed);for(const piece of availablePieces){for(let y=0;y<board.length;y++){for(let x=0;x<board[y].length;x++){if(canPlacePiece(board,piece,{x,y},this.colorIndex)){return false;// 还能放置拼图\n}}}}return true;// 无法放置任何拼图，需要结算\n}}","map":{"version":3,"names":["canPlacePiece","AIPlayer","constructor","color","colorIndex","getColorIndex","getColor","colorMap","red","yellow","blue","green","makeMove","board","pieces","availablePieces","filter","p","isUsed","length","sortedPieces","sort","a","b","type","piece","position","findBestPosition","positions","y","x","push","scoredPositions","map","pos","score","evaluatePosition","shape","getEdgeDistanceScore","getCornerDistanceScore","getSurroundingScore","getConnectionScore","boardSize","distanceToEdge","Math","min","distanceToCorner","sqrt","dy","dx","checkX","checkY","cell","row","col","boardX","boardY","corners","corner","shouldSettle"],"sources":["D:/blockus new/blockus-game/src/utils/aiPlayer.ts"],"sourcesContent":["// AI玩家算法\r\n\r\nimport { Piece, Position, PlayerColor } from '../types/game';\r\nimport { canPlacePiece, placePiece } from './gameEngine';\r\n\r\nexport class AIPlayer {\r\n  private color: PlayerColor;\r\n  private colorIndex: number;\r\n  \r\n  constructor(color: PlayerColor) {\r\n    this.color = color;\r\n    this.colorIndex = this.getColorIndex(color);\r\n  }\r\n  \r\n  // 公共方法：获取颜色\r\n  public getColor(): PlayerColor {\r\n    return this.color;\r\n  }\r\n  \r\n  // 获取颜色对应的索引\r\n  private getColorIndex(color: PlayerColor): number {\r\n    const colorMap: { [key in PlayerColor]: number } = {\r\n      red: 1,\r\n      yellow: 2,\r\n      blue: 3,\r\n      green: 4\r\n    };\r\n    return colorMap[color];\r\n  }\r\n  \r\n  // AI的主要决策函数\r\n  public makeMove(board: number[][], pieces: Piece[]): { piece: Piece; position: Position } | null {\r\n    const availablePieces = pieces.filter(p => !p.isUsed);\r\n    if (availablePieces.length === 0) return null;\r\n    \r\n    // 按优先级排序拼图：5格 > 4格 > 3格 > 2格 > 1格\r\n    const sortedPieces = availablePieces.sort((a, b) => b.type - a.type);\r\n    \r\n    // 尝试放置每个拼图\r\n    for (const piece of sortedPieces) {\r\n      const position = this.findBestPosition(board, piece);\r\n      if (position) {\r\n        return { piece, position };\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n  \r\n  // 寻找最佳放置位置\r\n  private findBestPosition(board: number[][], piece: Piece): Position | null {\r\n    const positions: Position[] = [];\r\n    \r\n    // 遍历棋盘寻找所有可能的位置\r\n    for (let y = 0; y < board.length; y++) {\r\n      for (let x = 0; x < board[y].length; x++) {\r\n        if (canPlacePiece(board, piece, { x, y }, this.colorIndex)) {\r\n          positions.push({ x, y });\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (positions.length === 0) return null;\r\n    \r\n    // 评分并选择最佳位置\r\n    const scoredPositions = positions.map(pos => ({\r\n      position: pos,\r\n      score: this.evaluatePosition(board, piece, pos)\r\n    }));\r\n    \r\n    // 按分数排序，选择最高分的位置\r\n    scoredPositions.sort((a, b) => b.score - a.score);\r\n    return scoredPositions[0].position;\r\n  }\r\n  \r\n  // 评估位置分数\r\n  private evaluatePosition(board: number[][], piece: Piece, position: Position): number {\r\n    let score = 0;\r\n    const { x, y } = position;\r\n    const { shape } = piece;\r\n    \r\n    // 优先选择靠近边缘的位置（向外拓展）\r\n    score += this.getEdgeDistanceScore(x, y, board.length);\r\n    \r\n    // 优先选择靠近角落的位置\r\n    score += this.getCornerDistanceScore(x, y, board.length);\r\n    \r\n    // 避免被对手包围\r\n    score += this.getSurroundingScore(board, x, y, shape);\r\n    \r\n    // 优先选择能连接更多己方拼图的位置\r\n    score += this.getConnectionScore(board, x, y, shape);\r\n    \r\n    return score;\r\n  }\r\n  \r\n  // 计算到边缘的距离分数\r\n  private getEdgeDistanceScore(x: number, y: number, boardSize: number): number {\r\n    const distanceToEdge = Math.min(x, y, boardSize - 1 - x, boardSize - 1 - y);\r\n    return (boardSize - distanceToEdge) * 10; // 越靠近边缘分数越高\r\n  }\r\n  \r\n  // 计算到角落的距离分数\r\n  private getCornerDistanceScore(x: number, y: number, boardSize: number): number {\r\n    const distanceToCorner = Math.min(\r\n      Math.sqrt(x * x + y * y),\r\n      Math.sqrt((boardSize - 1 - x) * (boardSize - 1 - x) + y * y),\r\n      Math.sqrt(x * x + (boardSize - 1 - y) * (boardSize - 1 - y)),\r\n      Math.sqrt((boardSize - 1 - x) * (boardSize - 1 - x) + (boardSize - 1 - y) * (boardSize - 1 - y))\r\n    );\r\n    return (boardSize - distanceToCorner) * 5; // 越靠近角落分数越高\r\n  }\r\n  \r\n  // 计算周围环境分数\r\n  private getSurroundingScore(board: number[][], x: number, y: number, shape: number[][]): number {\r\n    let score = 0;\r\n    \r\n    // 检查拼图周围8个方向\r\n    for (let dy = -1; dy <= 1; dy++) {\r\n      for (let dx = -1; dx <= 1; dx++) {\r\n        if (dx === 0 && dy === 0) continue;\r\n        \r\n        const checkX = x + dx;\r\n        const checkY = y + dy;\r\n        \r\n        if (checkX >= 0 && checkX < board.length && checkY >= 0 && checkY < board[0].length) {\r\n          const cell = board[checkY][checkX];\r\n          \r\n          if (cell === 0) {\r\n            score += 5; // 空位加分\r\n          } else if (cell === this.colorIndex) {\r\n            score += 2; // 己方拼图加分\r\n          } else {\r\n            score -= 3; // 对手拼图减分\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return score;\r\n  }\r\n  \r\n  // 计算连接性分数\r\n  private getConnectionScore(board: number[][], x: number, y: number, shape: number[][]): number {\r\n    let score = 0;\r\n    \r\n    // 检查拼图每个格子周围的连接情况\r\n    for (let row = 0; row < shape.length; row++) {\r\n      for (let col = 0; col < shape[row].length; col++) {\r\n        if (shape[row][col] === 0) continue;\r\n        \r\n        const boardX = x + col;\r\n        const boardY = y + row;\r\n        \r\n        // 检查四个角落\r\n        const corners = [\r\n          { dx: -1, dy: -1 }, { dx: 1, dy: -1 },\r\n          { dx: -1, dy: 1 }, { dx: 1, dy: 1 }\r\n        ];\r\n        \r\n        for (const corner of corners) {\r\n          const checkX = boardX + corner.dx;\r\n          const checkY = boardY + corner.dy;\r\n          \r\n          if (checkX >= 0 && checkX < board.length && checkY >= 0 && checkY < board[0].length) {\r\n            if (board[checkY][checkX] === this.colorIndex) {\r\n              score += 8; // 角落连接加分\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return score;\r\n  }\r\n  \r\n  // 检查是否需要结算（无法放置任何拼图）\r\n  public shouldSettle(board: number[][], pieces: Piece[]): boolean {\r\n    const availablePieces = pieces.filter(p => !p.isUsed);\r\n    \r\n    for (const piece of availablePieces) {\r\n      for (let y = 0; y < board.length; y++) {\r\n        for (let x = 0; x < board[y].length; x++) {\r\n          if (canPlacePiece(board, piece, { x, y }, this.colorIndex)) {\r\n            return false; // 还能放置拼图\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return true; // 无法放置任何拼图，需要结算\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}